<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Visitenkarte – Weiß/Schwarz Generator</title>
  <meta name="description" content="Visitenkarte Generator: Eingabefelder, QR-Werkstatt, Vorschau, Druckvorlage (weiß/schwarz), DE/EN, LocalStorage." />
  <meta name="robots" content="noindex,nofollow" />

  <style>
    :root{
      --bg:#ffffff;
      --ink:#000000;
      --muted:#333333;
      --line:#000000;
      --panel:#ffffff;

      /* Visitenkarte (Standard): 85 x 55 mm */
      --card-w:85mm;
      --card-h:55mm;
      --card-pad:4.5mm;
      --radius:2mm;
    }

    html,body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }

    .wrap{ max-width:1100px; margin:0 auto; padding:18px 16px 34px; }

    header{
      display:flex; gap:12px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap; margin-bottom:14px;
    }

    .title{ line-height:1.15; }
    .title h1{ margin:0; font-size:20px; font-weight:800; letter-spacing:.2px; }
    .title p{ margin:6px 0 0; color:var(--muted); font-size:13px; max-width:62ch; }

    .lang{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn{
      appearance:none; border:1px solid var(--line); background:#fff; color:#000;
      padding:8px 10px; border-radius:8px; font-weight:700; font-size:13px; cursor:pointer;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.small{ padding:7px 9px; font-size:12px; }
    .btn.primary{ background:#000; color:#fff; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
      align-items:start;
    }

    .panel{
      border:1px solid var(--line);
      border-radius:12px;
      padding:14px;
      background:var(--panel);
    }
    .panel h2{ margin:0 0 10px; font-size:15px; font-weight:800; }

    .form{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .field{ display:flex; flex-direction:column; gap:6px; }
    .field.full{ grid-column:1 / -1; }

    label{ font-size:12px; font-weight:800; letter-spacing:.2px; }
    input{
      border:1px solid var(--line);
      border-radius:10px;
      padding:10px 10px;
      font-size:14px;
      outline:none;
      background:#fff;
      color:#000;
    }
    input::placeholder{ color:#777; }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .hint{ font-size:12px; color:var(--muted); line-height:1.35; }

    /* Preview Card */
    .previewWrap{ display:flex; flex-direction:column; gap:12px; align-items:flex-start; }
    .cardSheet{
      background:#fff;
      padding:12px;
      border:1px dashed #000;
      border-radius:12px;
    }

    .card{
      width:var(--card-w);
      height:var(--card-h);
      border:1px solid #000;
      border-radius:var(--radius);
      padding:var(--card-pad);
      box-sizing:border-box;
      background:#fff;
      color:#000;
      position:relative;
      overflow:hidden;
    }

    /* Textlogo oben rechts */
    .clubMark{
      position:absolute;
      top:var(--card-pad);
      right:var(--card-pad);
      font-weight:900;
      font-size:9.5pt;
      letter-spacing:.2px;
      color:#000;
      line-height:1;
      white-space:nowrap;
    }

    .cName{
      font-weight:900;
      font-size:12.5pt;
      line-height:1.1;
      letter-spacing:.2px;
      margin:0;
      word-break:break-word;
      padding-right:22mm;
    }
    .cRole{
      margin:2mm 0 0;
      font-weight:700;
      font-size:9.5pt;
      color:#000;
      word-break:break-word;
      padding-right:22mm;
    }

    .cLine{
      height:0;
      border-top:1px solid #000;
      margin:3.2mm 0 3.2mm;
      opacity:1;
    }

    .cInfo{
      display:grid;
      grid-template-columns: 1fr;
      gap:1.2mm;
      font-size:9.2pt;
      line-height:1.15;
      color:#000;
      word-break:break-word;
      padding-right:22mm;
    }

    .mono{ font-variant-numeric: tabular-nums; font-feature-settings:"tnum" 1; }
    .empty{ opacity:.35; font-style:italic; }
    .footerNote{ font-size:12px; color:var(--muted); }

    /* QR auf Karte */
    .qrBox{
      position:absolute;
      right:var(--card-pad);
      bottom:var(--card-pad);
      width:18mm;
      height:18mm;
      border:1px solid #000;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .qrBox.isEmpty{ opacity:.12; }
    .qrBox svg{ width:100%; height:100%; display:block; }

    /* QR Werkstatt */
    .qrWorkshopBox{
      border:1px solid #000;
      border-radius:12px;
      padding:12px;
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      background:#fff;
    }
    .qrLarge{
      width:46mm;
      height:46mm;
      border:1px solid #000;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
      box-sizing:border-box;
    }
    .qrLarge svg{ width:100%; height:100%; display:block; }

    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .cardSheet{ width:100%; }
    }

    @media print{
      @page{ size: A4; margin: 12mm; }
      body{ background:#fff; }
      header, .panel.formPanel, .panel.qrPanel, .footerNote, .lang, .hint, .actions{ display:none !important; }
      .wrap{ padding:0; max-width:none; }
      .grid{ display:block; }
      .panel{ border:none; padding:0; }
      .cardSheet{ border:none; padding:0; border-radius:0; }
      .card{ margin:0 auto; }

      .crop{
        position:relative;
        width:var(--card-w);
        height:var(--card-h);
        margin:0 auto;
      }
      .crop i{
        position:absolute;
        width:6mm; height:6mm;
        border-color:#000;
        border-style:solid;
        border-width:0;
        display:block;
      }
      .crop i.tl{ left:-6mm; top:-6mm; border-left-width:0.25mm; border-top-width:0.25mm; }
      .crop i.tr{ right:-6mm; top:-6mm; border-right-width:0.25mm; border-top-width:0.25mm; }
      .crop i.bl{ left:-6mm; bottom:-6mm; border-left-width:0.25mm; border-bottom-width:0.25mm; }
      .crop i.br{ right:-6mm; bottom:-6mm; border-right-width:0.25mm; border-bottom-width:0.25mm; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1 data-i18n="h1">Visitenkarte – Weiß/Schwarz</h1>
        <p data-i18n="sub">Eingaben → Vorschau → (optional QR importieren) → Drucken / als PDF speichern.</p>
      </div>

      <div class="lang">
        <button class="btn small" id="btnDE" type="button">DE</button>
        <button class="btn small" id="btnEN" type="button">EN</button>
        <button class="btn primary" id="btnPrint" type="button" data-i18n="printBtn">Drucken / als PDF speichern</button>
      </div>
    </header>

    <div class="grid">
      <!-- FORM -->
      <section class="panel formPanel">
        <h2 data-i18n="formTitle">Eingabefelder</h2>

        <div class="form" id="form">
          <div class="field">
            <label for="firstName" data-i18n="firstNameLabel">Vorname</label>
            <input id="firstName" type="text" placeholder="Max" autocomplete="given-name" />
          </div>

          <div class="field">
            <label for="lastName" data-i18n="lastNameLabel">Nachname</label>
            <input id="lastName" type="text" placeholder="Mustermann" autocomplete="family-name" />
          </div>

          <div class="field full">
            <label for="street" data-i18n="streetLabel">Straße & Hausnummer</label>
            <input id="street" type="text" placeholder="Musterstraße 12" autocomplete="street-address" />
          </div>

          <div class="field">
            <label for="zip" data-i18n="zipLabel">PLZ</label>
            <input id="zip" type="text" inputmode="numeric" placeholder="12345" autocomplete="postal-code" />
          </div>

          <div class="field">
            <label for="city" data-i18n="cityLabel">Ort</label>
            <input id="city" type="text" placeholder="Musterstadt" autocomplete="address-level2" />
          </div>

          <div class="field">
            <label for="mobile" data-i18n="mobileLabel">Mobil</label>
            <input id="mobile" type="tel" placeholder="+49 170 1234567" autocomplete="tel" />
          </div>

          <div class="field">
            <label for="email" data-i18n="emailLabel">E-Mail</label>
            <input id="email" type="email" placeholder="name@domain.de" autocomplete="email" />
          </div>

          <div class="field full">
            <label for="status" data-i18n="statusLabel">Status</label>
            <input id="status" type="text" data-i18n-ph="statusPH" placeholder="Mitglied, Mentor, Promotor, Sprecher, Dozent" autocomplete="off" />
          </div>
        </div>

        <div class="actions">
          <button class="btn" id="btnClear" type="button" data-i18n="clearBtn">Felder leeren</button>
          <button class="btn" id="btnCopy" type="button" data-i18n="copyBtn">Text kopieren</button>
          <div class="hint" data-i18n="hint">Tipp: Nach dem Klick auf „Drucken / als PDF speichern“ im Druckdialog „Als PDF sichern“ wählen.</div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel">
        <h2 data-i18n="previewTitle">Vorschau</h2>

        <div class="previewWrap">
          <div class="cardSheet" aria-label="Print area">
            <div class="crop">
              <i class="tl"></i><i class="tr"></i><i class="bl"></i><i class="br"></i>

              <div class="card" id="card">
                <div class="clubMark">FSA-Club</div>

                <p class="cName" id="pName">—</p>
                <p class="cRole" id="pAddr1">—</p>

                <div class="cLine"></div>

                <div class="cInfo">
                  <div class="mono" id="pAddr2">—</div>
                  <div class="mono" id="pMobile">—</div>
                  <div class="mono" id="pEmail">—</div>
                  <div class="mono" id="pStatus">—</div>
                </div>

                <!-- QR auf Karte: nur nach Import -->
                <div class="qrBox isEmpty" id="qrBox" aria-label="QR Code">
                  <div id="qrOnCard"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="footerNote" data-i18n="privacy">Hinweis: Speicherung erfolgt lokal im Browser (LocalStorage). Keine Übertragung.</div>
        </div>
      </section>

      <!-- QR WERKSTATT -->
      <section class="panel qrPanel" style="grid-column: 1 / -1;">
        <h2 data-i18n="qrTitle">QR-Werkstatt (Webadresse → QR → Import)</h2>

        <div class="form">
          <div class="field full">
            <label for="qrWebsite" data-i18n="qrWebLabel">Webadresse (für QR)</label>
            <input id="qrWebsite" type="text" placeholder="https://deine-domain.de/michael-rau" autocomplete="url" />
          </div>
        </div>

        <div class="qrWorkshopBox" style="margin-top:10px;">
          <div class="qrLarge" aria-label="QR Vorschau">
            <div id="qrPreview"></div>
          </div>

          <div style="flex:1; min-width:240px;">
            <div class="hint" data-i18n="qrHint">
              Hier wird der QR separat erzeugt. Erst mit „In Visitenkarte übernehmen“ wird er auf die Karte gesetzt.
              Lange Webadressen müssen dann nicht mehr als Text gedruckt werden.
            </div>

            <div class="actions" style="margin-top:10px;">
              <button class="btn" id="btnMakeQr" type="button" data-i18n="qrMakeBtn">QR erzeugen</button>
              <button class="btn primary" id="btnImportQr" type="button" data-i18n="qrImportBtn">In Visitenkarte übernehmen</button>
              <button class="btn" id="btnClearQr" type="button" data-i18n="qrClearBtn">QR löschen</button>
            </div>

            <div class="hint" id="qrStatusLine" style="margin-top:6px;"></div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    (function(){
      "use strict";

      const LS_KEY = "fsa_vcard_white_black_v3";
      const LS_LANG = "fsa_lang_vcard";
      const LS_QR_IMPORTED = "fsa_vcard_qr_imported_svg";
      const LS_QR_WEBSITE = "fsa_vcard_qr_website";

      const els = {
        firstName: document.getElementById("firstName"),
        lastName: document.getElementById("lastName"),
        street: document.getElementById("street"),
        zip: document.getElementById("zip"),
        city: document.getElementById("city"),
        mobile: document.getElementById("mobile"),
        email: document.getElementById("email"),
        status: document.getElementById("status"),

        pName: document.getElementById("pName"),
        pAddr1: document.getElementById("pAddr1"),
        pAddr2: document.getElementById("pAddr2"),
        pMobile: document.getElementById("pMobile"),
        pEmail: document.getElementById("pEmail"),
        pStatus: document.getElementById("pStatus"),

        qrBox: document.getElementById("qrBox"),
        qrOnCard: document.getElementById("qrOnCard"),

        qrWebsite: document.getElementById("qrWebsite"),
        qrPreview: document.getElementById("qrPreview"),
        btnMakeQr: document.getElementById("btnMakeQr"),
        btnImportQr: document.getElementById("btnImportQr"),
        btnClearQr: document.getElementById("btnClearQr"),
        qrStatusLine: document.getElementById("qrStatusLine"),

        btnPrint: document.getElementById("btnPrint"),
        btnClear: document.getElementById("btnClear"),
        btnCopy: document.getElementById("btnCopy"),
        btnDE: document.getElementById("btnDE"),
        btnEN: document.getElementById("btnEN"),
      };

      const i18n = {
        de: {
          h1:"Visitenkarte – Weiß/Schwarz",
          sub:"Eingaben → Vorschau → (optional QR importieren) → Drucken / als PDF speichern.",
          formTitle:"Eingabefelder",
          firstNameLabel:"Vorname",
          lastNameLabel:"Nachname",
          streetLabel:"Straße & Hausnummer",
          zipLabel:"PLZ",
          cityLabel:"Ort",
          mobileLabel:"Mobil",
          emailLabel:"E-Mail",
          statusLabel:"Status",
          statusPH:"Mitglied, Mentor, Promotor, Sprecher, Dozent",
          previewTitle:"Vorschau",
          printBtn:"Drucken / als PDF speichern",
          clearBtn:"Felder leeren",
          copyBtn:"Text kopieren",
          hint:"Tipp: Nach dem Klick auf „Drucken / als PDF speichern“ im Druckdialog „Als PDF sichern“ wählen.",
          privacy:"Hinweis: Speicherung erfolgt lokal im Browser (LocalStorage). Keine Übertragung.",
          copied:"Kopiert.",
          copyFail:"Kopieren nicht möglich.",
          confirmClear:"Wirklich alle Felder leeren?",
          qrTitle:"QR-Werkstatt (Webadresse → QR → Import)",
          qrWebLabel:"Webadresse (für QR)",
          qrHint:"Hier wird der QR separat erzeugt. Erst mit „In Visitenkarte übernehmen“ wird er auf die Karte gesetzt. Lange Webadressen müssen dann nicht mehr als Text gedruckt werden.",
          qrMakeBtn:"QR erzeugen",
          qrImportBtn:"In Visitenkarte übernehmen",
          qrClearBtn:"QR löschen",
          qrNoUrl:"Bitte Webadresse eintragen.",
          qrReady:"QR bereit. Jetzt „In Visitenkarte übernehmen“.",
          qrImported:"QR wurde in die Visitenkarte übernommen.",
          qrConfirm:"QR in die Visitenkarte übernehmen?"
        },
        en: {
          h1:"Business Card – White/Black",
          sub:"Inputs → Preview → (optional import QR) → Print / save as PDF.",
          formTitle:"Input fields",
          firstNameLabel:"First name",
          lastNameLabel:"Last name",
          streetLabel:"Street & number",
          zipLabel:"ZIP",
          cityLabel:"City",
          mobileLabel:"Mobile",
          emailLabel:"Email",
          statusLabel:"Status",
          statusPH:"Member, Mentor, Promoter, Speaker, Lecturer",
          previewTitle:"Preview",
          printBtn:"Print / save as PDF",
          clearBtn:"Clear fields",
          copyBtn:"Copy text",
          hint:"Tip: After clicking “Print / save as PDF”, choose “Save as PDF” in the print dialog.",
          privacy:"Note: Saved locally in your browser (LocalStorage). No transmission.",
          copied:"Copied.",
          copyFail:"Copy not available.",
          confirmClear:"Really clear all fields?",
          qrTitle:"QR Workshop (website → QR → import)",
          qrWebLabel:"Website (for QR)",
          qrHint:"The QR is generated separately. Only with “Import to business card” it will be placed on the card. Long URLs do not need to be printed as text.",
          qrMakeBtn:"Generate QR",
          qrImportBtn:"Import to business card",
          qrClearBtn:"Clear QR",
          qrNoUrl:"Please enter a website.",
          qrReady:"QR ready. Now click “Import to business card”.",
          qrImported:"QR imported into the business card.",
          qrConfirm:"Import QR into the business card?"
        }
      };

      function safe(v){ return (v||"").toString().trim(); }

      function setText(node, value, placeholder){
        const v = safe(value);
        if(v){
          node.textContent = v;
          node.classList.remove("empty");
        }else{
          node.textContent = placeholder;
          node.classList.add("empty");
        }
      }

      function normalizeWebsite(url){
        const v = safe(url);
        if(!v) return "";
        if(/^https?:\/\//i.test(v)) return v;
        return "https://" + v;
      }

      function load(){
        try{
          const raw = localStorage.getItem(LS_KEY);
          if(raw){
            const data = JSON.parse(raw);
            if(data && typeof data === "object"){
              els.firstName.value = data.firstName || "";
              els.lastName.value  = data.lastName  || "";
              els.street.value    = data.street    || "";
              els.zip.value       = data.zip       || "";
              els.city.value      = data.city      || "";
              els.mobile.value    = data.mobile    || "";
              els.email.value     = data.email     || "";
              els.status.value    = data.status    || "";
            }
          }
        }catch(e){}

        els.qrWebsite.value = localStorage.getItem(LS_QR_WEBSITE) || "";

        const importedSvg = localStorage.getItem(LS_QR_IMPORTED) || "";
        if(importedSvg){
          els.qrOnCard.innerHTML = importedSvg;
          els.qrBox.classList.remove("isEmpty");
        }else{
          els.qrOnCard.innerHTML = "";
          els.qrBox.classList.add("isEmpty");
        }
      }

      function save(){
        const data = {
          firstName: safe(els.firstName.value),
          lastName:  safe(els.lastName.value),
          street:    safe(els.street.value),
          zip:       safe(els.zip.value),
          city:      safe(els.city.value),
          mobile:    safe(els.mobile.value),
          email:     safe(els.email.value),
          status:    safe(els.status.value),
        };
        try{ localStorage.setItem(LS_KEY, JSON.stringify(data)); }catch(e){}
      }

      function getLang(){
        const v = (localStorage.getItem(LS_LANG) || "de").toLowerCase();
        return (v === "en") ? "en" : "de";
      }

      function setLang(lang){
        const v = (lang === "en") ? "en" : "de";
        localStorage.setItem(LS_LANG, v);
        applyI18n();
      }

      function applyI18n(){
        const lang = getLang();
        const dict = i18n[lang];

        document.documentElement.lang = lang;

        document.querySelectorAll("[data-i18n]").forEach(n=>{
          const key = n.getAttribute("data-i18n");
          if(dict[key]) n.textContent = dict[key];
        });

        document.querySelectorAll("[data-i18n-ph]").forEach(n=>{
          const key = n.getAttribute("data-i18n-ph");
          if(dict[key]) n.setAttribute("placeholder", dict[key]);
        });

        els.btnDE.style.opacity = (lang === "de") ? "1" : ".55";
        els.btnEN.style.opacity = (lang === "en") ? "1" : ".55";
      }

      /* =========================
         QR FULL SPEC (qrcodegen)
         - echtes ECC + Masking
         - SVG, crisp, schwarz/weiß
      ========================= */
      function makeQrSvgFullSpec(text, targetPx){
        const border = 4; // Quiet Zone (wichtig fürs Scannen!)
        const qr = qrcodegen.QrCode.encodeText(text, qrcodegen.QrCode.Ecc.MEDIUM);

        const dim = qr.size + border*2;
        const scale = Math.max(1, Math.floor(targetPx / dim));
        const svgSize = dim * scale;

        let path = "";
        for(let y=0;y<qr.size;y++){
          for(let x=0;x<qr.size;x++){
            if(qr.getModule(x,y)){
              const xx = (x + border) * scale;
              const yy = (y + border) * scale;
              path += `M${xx},${yy}h${scale}v${scale}h-${scale}z `;
            }
          }
        }

        return `<svg xmlns="http://www.w3.org/2000/svg" width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" shape-rendering="crispEdges" aria-label="QR">
  <rect width="100%" height="100%" fill="#fff"/>
  <path d="${path.trim()}" fill="#000"/>
</svg>`;
      }

      /* ========= Render Card ========= */
      function renderCard(){
        const first = safe(els.firstName.value);
        const last  = safe(els.lastName.value);
        const fullName = (first + " " + last).trim();

        const street = safe(els.street.value);
        const zip = safe(els.zip.value);
        const city = safe(els.city.value);
        const addr2 = ((zip ? zip : "") + (zip && city ? " " : "") + (city ? city : "")).trim();

        const mobile = safe(els.mobile.value);
        const email  = safe(els.email.value);
        const status = safe(els.status.value);

        setText(els.pName, fullName, "—");
        setText(els.pAddr1, street, "—");
        setText(els.pAddr2, addr2, "—");

        setText(els.pMobile, mobile ? ("Mobil: " + mobile) : "", "—");
        setText(els.pEmail,  email  ? ("E-Mail: " + email)  : "", "—");
        setText(els.pStatus, status ? ("Status: " + status) : "", "—");

        save();
      }

      /* ========= QR Workshop ========= */
      function setQrStatus(msg){
        els.qrStatusLine.textContent = msg || "";
      }

      function makeQrPreview(){
        const t = i18n[getLang()];
        const raw = safe(els.qrWebsite.value);
        if(!raw){
          els.qrPreview.innerHTML = "";
          setQrStatus(t.qrNoUrl);
          return "";
        }
        const url = normalizeWebsite(raw);

        let svg = "";
        try{
          // Werkstatt groß (scan-sicher)
          svg = makeQrSvgFullSpec(url, 520);
        }catch(e){
          els.qrPreview.innerHTML = "";
          setQrStatus("QR Fehler (URL zu lang oder ungültig).");
          return "";
        }

        els.qrPreview.innerHTML = svg;
        localStorage.setItem(LS_QR_WEBSITE, raw);
        setQrStatus(t.qrReady);
        return svg;
      }

      function importQrToCard(svg){
        const t = i18n[getLang()];
        if(!svg) return;
        if(!confirm(t.qrConfirm)) return;

        // Für die Karte kleiner neu rendern (sauber & ruhig)
        const raw = safe(els.qrWebsite.value);
        const url = normalizeWebsite(raw);

        let smallSvg = "";
        try{
          smallSvg = makeQrSvgFullSpec(url, 220);
        }catch(e){
          return;
        }

        els.qrOnCard.innerHTML = smallSvg;
        els.qrBox.classList.remove("isEmpty");
        localStorage.setItem(LS_QR_IMPORTED, smallSvg);
        setQrStatus(t.qrImported);
      }

      function clearQr(){
        els.qrPreview.innerHTML = "";
        els.qrOnCard.innerHTML = "";
        els.qrBox.classList.add("isEmpty");
        localStorage.removeItem(LS_QR_IMPORTED);
      }

      function wire(){
        ["firstName","lastName","street","zip","city","mobile","email","status"].forEach(id=>{
          els[id].addEventListener("input", renderCard);
          els[id].addEventListener("change", renderCard);
        });

        els.btnPrint.addEventListener("click", ()=>{
          renderCard();
          window.print();
        });

        els.btnClear.addEventListener("click", ()=>{
          const t = i18n[getLang()];
          if(!confirm(t.confirmClear)) return;

          els.firstName.value = "";
          els.lastName.value  = "";
          els.street.value    = "";
          els.zip.value       = "";
          els.city.value      = "";
          els.mobile.value    = "";
          els.email.value     = "";
          els.status.value    = "";
          save();
          renderCard();
        });

        els.btnCopy.addEventListener("click", async ()=>{
          const t = i18n[getLang()];

          const first = safe(els.firstName.value);
          const last  = safe(els.lastName.value);
          const fullName = (first + " " + last).trim();
          const street = safe(els.street.value);
          const zip = safe(els.zip.value);
          const city = safe(els.city.value);
          const addr2 = ((zip ? zip : "") + (zip && city ? " " : "") + (city ? city : "")).trim();
          const mobile = safe(els.mobile.value);
          const email  = safe(els.email.value);
          const status = safe(els.status.value);

          const lines = [
            fullName || "",
            street || "",
            addr2 || "",
            mobile ? ("Mobil: " + mobile) : "",
            email ? ("E-Mail: " + email) : "",
            status ? ("Status: " + status) : ""
          ].filter(Boolean);

          const text = lines.join("\n");
          try{
            if(navigator.clipboard && navigator.clipboard.writeText){
              await navigator.clipboard.writeText(text);
              els.btnCopy.textContent = t.copied;
              setTimeout(()=>{ els.btnCopy.textContent = t.copyBtn; }, 900);
            }else{
              throw new Error("no clipboard");
            }
          }catch(e){
            alert(t.copyFail);
          }
        });

        els.btnDE.addEventListener("click", ()=>{ setLang("de"); setQrStatus(""); });
        els.btnEN.addEventListener("click", ()=>{ setLang("en"); setQrStatus(""); });

        els.btnMakeQr.addEventListener("click", ()=>{ makeQrPreview(); });
        els.btnImportQr.addEventListener("click", ()=>{
          const svg = els.qrPreview.innerHTML || makeQrPreview();
          importQrToCard(svg);
        });
        els.btnClearQr.addEventListener("click", ()=>{
          clearQr();
          setQrStatus("");
        });
      }

      // init
      load();
      applyI18n();
      wire();
      renderCard();
      if(safe(els.qrWebsite.value)) makeQrPreview();
    })();

    /* =========================================================
       Embedded QR lib: qrcodegen (Nayuki) – full spec, offline
       ========================================================= */
    /* eslint-disable */
    var qrcodegen = (function() {
      "use strict";
      function QrCode(size, errorCorrectionLevel, modules, isFunction) {
        this.size = size;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.modules = modules;
        this.isFunction = isFunction;
      }
      QrCode.prototype.getModule = function(x, y) { return this.modules[y][x]; };

      QrCode.encodeText = function(text, ecl) {
        var segs = QrSegment.makeSegments(text);
        return QrCode.encodeSegments(segs, ecl);
      };

      QrCode.encodeSegments = function(segs, ecl) {
        if (ecl === void 0) ecl = QrCode.Ecc.MEDIUM;
        for (var version = 1; version <= 40; version++) {
          var dataUsedBits = QrSegment.getTotalBits(segs, version);
          if (dataUsedBits !== null && dataUsedBits <= QrCode.getNumDataCodewords(version, ecl) * 8) {
            return QrCode.encodeSegmentsAdvanced(segs, ecl, version, version, -1, true);
          }
        }
        throw "Data too long";
      };

      QrCode.encodeSegmentsAdvanced = function(segs, ecl, minVersion, maxVersion, mask, boostEcl) {
        if (boostEcl) {
          for (var newEcl = QrCode.Ecc.HIGH; newEcl !== null; newEcl = newEcl === QrCode.Ecc.LOW ? null : QrCode.Ecc.values[newEcl.ordinal - 1]) {
            if (QrCode.getNumDataCodewords(maxVersion, newEcl) >= QrCode.getNumDataCodewords(maxVersion, ecl)) {
              ecl = newEcl;
              break;
            }
          }
        }
        var version, dataUsedBits, dataCapacityBits;
        for (version = minVersion; ; version++) {
          dataUsedBits = QrSegment.getTotalBits(segs, version);
          if (dataUsedBits !== null) {
            dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
            if (dataUsedBits <= dataCapacityBits) break;
          }
          if (version >= maxVersion) throw "Data too long";
        }

        var bb = [];
        segs.forEach(function(seg) {
          QrCode.appendBits(seg.mode.modeBits, 4, bb);
          QrCode.appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
          Array.prototype.push.apply(bb, seg.data);
        });

        QrCode.appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
        QrCode.appendBits(0, (8 - bb.length % 8) % 8, bb);

        for (var padByte = 0xEC; bb.length < dataCapacityBits; padByte ^= 0xEC ^ 0x11)
          QrCode.appendBits(padByte, 8, bb);

        var dataCodewords = [];
        while (dataCodewords.length * 8 < bb.length) {
          var b = 0;
          for (var i = 0; i < 8; i++)
            b = (b << 1) | (bb[dataCodewords.length * 8 + i] ? 1 : 0);
          dataCodewords.push(b);
        }

        var allCodewords = QrCode.addEccAndInterleave(dataCodewords, version, ecl);

        var size = version * 4 + 17;
        var modules = [];
        var isFunction = [];
        for (var y = 0; y < size; y++) {
          modules.push([]);
          isFunction.push([]);
          for (var x = 0; x < size; x++) {
            modules[y].push(false);
            isFunction[y].push(false);
          }
        }

        var qr = new QrCode(size, ecl, modules, isFunction);
        qr.drawFunctionPatterns(version);
        qr.drawCodewords(allCodewords);

        if (mask === -1) {
          var minPenalty = 1e9;
          for (var m = 0; m < 8; m++) {
            qr.applyMask(m);
            qr.drawFormatBits(m);
            var penalty = qr.getPenaltyScore();
            if (penalty < minPenalty) {
              mask = m;
              minPenalty = penalty;
            }
            qr.applyMask(m);
          }
        }

        qr.applyMask(mask);
        qr.drawFormatBits(mask);
        qr.isFunction = isFunction;
        return qr;
      };

      QrCode.prototype.drawFunctionPatterns = function(version) {
        for (var i = 0; i < this.size; i++) {
          this.setFunctionModule(6, i, i % 2 === 0);
          this.setFunctionModule(i, 6, i % 2 === 0);
        }
        this.drawFinderPattern(3, 3);
        this.drawFinderPattern(this.size - 4, 3);
        this.drawFinderPattern(3, this.size - 4);

        var alignPatPos = QrCode.getAlignmentPatternPositions(version);
        var numAlign = alignPatPos.length;
        for (var i = 0; i < numAlign; i++) {
          for (var j = 0; j < numAlign; j++) {
            if (i === 0 && j === 0) continue;
            if (i === 0 && j === numAlign - 1) continue;
            if (i === numAlign - 1 && j === 0) continue;
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
          }
        }

        this.setFunctionModule(8, this.size - 8, true);
        for (var i = 0; i < 9; i++) {
          if (i !== 6) {
            this.setFunctionModule(8, i, false);
            this.setFunctionModule(i, 8, false);
          }
        }
        for (var i = 0; i < 8; i++) {
          this.setFunctionModule(this.size - 1 - i, 8, false);
          this.setFunctionModule(8, this.size - 1 - i, false);
        }
        this.setFunctionModule(8, 8, false);

        if (version >= 7) {
          for (var i = 0; i < 6; i++) {
            for (var j = 0; j < 3; j++) {
              this.setFunctionModule(this.size - 11 + j, i, false);
              this.setFunctionModule(i, this.size - 11 + j, false);
            }
          }
        }
      };

      QrCode.prototype.drawFormatBits = function(mask) {
        var data = (this.errorCorrectionLevel.formatBits << 3) | mask;
        var rem = data;
        for (var i = 0; i < 10; i++)
          rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
        var bits = ((data << 10) | (rem & 0x3FF)) ^ 0x5412;

        for (var i = 0; i <= 5; i++) this.setFunctionModule(8, i, QrCode.getBit(bits, i));
        this.setFunctionModule(8, 7, QrCode.getBit(bits, 6));
        this.setFunctionModule(8, 8, QrCode.getBit(bits, 7));
        this.setFunctionModule(7, 8, QrCode.getBit(bits, 8));
        for (var i = 9; i < 15; i++) this.setFunctionModule(14 - i, 8, QrCode.getBit(bits, i));

        for (var i = 0; i < 8; i++) this.setFunctionModule(this.size - 1 - i, 8, QrCode.getBit(bits, i));
        for (var i = 8; i < 15; i++) this.setFunctionModule(8, this.size - 15 + i, QrCode.getBit(bits, i));
      };

      QrCode.prototype.drawFinderPattern = function(x, y) {
        for (var dy = -4; dy <= 4; dy++) {
          for (var dx = -4; dx <= 4; dx++) {
            var dist = Math.max(Math.abs(dx), Math.abs(dy));
            var xx = x + dx, yy = y + dy;
            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
              this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4);
          }
        }
      };

      QrCode.prototype.drawAlignmentPattern = function(x, y) {
        for (var dy = -2; dy <= 2; dy++) {
          for (var dx = -2; dx <= 2; dx++)
            this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) !== 1);
        }
      };

      QrCode.prototype.setFunctionModule = function(x, y, isBlack) {
        this.modules[y][x] = isBlack;
        this.isFunction[y][x] = true;
      };

      QrCode.prototype.drawCodewords = function(data) {
        var i = 0;
        for (var right = this.size - 1; right >= 1; right -= 2) {
          if (right === 6) right = 5;
          for (var vert = 0; vert < this.size; vert++) {
            for (var j = 0; j < 2; j++) {
              var x = right - j;
              var y = ((right + 1) & 2) === 0 ? this.size - 1 - vert : vert;
              if (!this.isFunction[y][x] && i < data.length * 8) {
                this.modules[y][x] = QrCode.getBit(data[i >>> 3], 7 - (i & 7));
                i++;
              }
            }
          }
        }
      };

      QrCode.prototype.applyMask = function(mask) {
        for (var y = 0; y < this.size; y++) {
          for (var x = 0; x < this.size; x++) {
            var invert;
            switch (mask) {
              case 0: invert = (x + y) % 2 === 0; break;
              case 1: invert = y % 2 === 0; break;
              case 2: invert = x % 3 === 0; break;
              case 3: invert = (x + y) % 3 === 0; break;
              case 4: invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0; break;
              case 5: invert = x * y % 2 + x * y % 3 === 0; break;
              case 6: invert = (x * y % 2 + x * y % 3) % 2 === 0; break;
              case 7: invert = ((x + y) % 2 + x * y % 3) % 2 === 0; break;
              default: throw "Assertion error";
            }
            if (!this.isFunction[y][x] && invert)
              this.modules[y][x] = !this.modules[y][x];
          }
        }
      };

      QrCode.prototype.getPenaltyScore = function() {
        var result = 0;
        for (var y = 0; y < this.size; y++) {
          var runColor = false;
          var runLen = 0;
          for (var x = 0; x < this.size; x++) {
            var color = this.modules[y][x];
            if (x === 0 || color !== runColor) {
              runColor = color;
              runLen = 1;
            } else {
              runLen++;
              if (runLen === 5) result += 3;
              else if (runLen > 5) result++;
            }
          }
        }
        for (var x = 0; x < this.size; x++) {
          var runColor = false;
          var runLen = 0;
          for (var y = 0; y < this.size; y++) {
            var color = this.modules[y][x];
            if (y === 0 || color !== runColor) {
              runColor = color;
              runLen = 1;
            } else {
              runLen++;
              if (runLen === 5) result += 3;
              else if (runLen > 5) result++;
            }
          }
        }
        for (var y = 0; y < this.size - 1; y++) {
          for (var x = 0; x < this.size - 1; x++) {
            var c = this.modules[y][x];
            if (c === this.modules[y][x + 1] && c === this.modules[y + 1][x] && c === this.modules[y + 1][x + 1])
              result += 3;
          }
        }
        var black = 0;
        for (var y = 0; y < this.size; y++)
          for (var x = 0; x < this.size; x++)
            if (this.modules[y][x]) black++;
        var total = this.size * this.size;
        var k = Math.abs(black * 20 - total * 10) / total;
        result += Math.floor(k) * 10;
        return result;
      };

      QrCode.getAlignmentPatternPositions = function(ver) {
        if (ver === 1) return [];
        var numAlign = Math.floor(ver / 7) + 2;
        var step = ver === 32 ? 26 : Math.ceil((ver * 4 + 17 - 13) / (numAlign - 1) / 2) * 2;
        var result = [6];
        for (var i = 0; i < numAlign - 2; i++)
          result.push(ver * 4 + 17 - 7 - (numAlign - 2 - 1 - i) * step);
        result.push(ver * 4 + 17 - 7);
        return result;
      };

      QrCode.addEccAndInterleave = function(data, version, ecl) {
        var numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][version];
        var blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][version];
        var rawCodewords = QrCode.getNumRawDataModules(version) / 8;
        var numShortBlocks = numBlocks - rawCodewords % numBlocks;
        var shortBlockLen = Math.floor(rawCodewords / numBlocks);

        var blocks = [];
        var k = 0;
        for (var i = 0; i < numBlocks; i++) {
          var datLen = shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1);
          var dat = data.slice(k, k + datLen);
          k += datLen;
          var ecc = QrCode.reedSolomonComputeRemainder(dat, QrCode.reedSolomonComputeDivisor(blockEccLen));
          blocks.push(dat.concat(ecc));
        }

        var result = [];
        for (var i = 0; i < blocks[0].length; i++) {
          for (var j = 0; j < blocks.length; j++) {
            if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
              result.push(blocks[j][i]);
          }
        }
        return result;
      };

      QrCode.reedSolomonComputeDivisor = function(degree) {
        var result = [];
        for (var i = 0; i < degree - 1; i++) result.push(0);
        result.push(1);
        var root = 1;
        for (var i = 0; i < degree; i++) {
          for (var j = 0; j < result.length; j++) {
            result[j] = QrCode.reedSolomonMultiply(result[j], root);
            if (j + 1 < result.length) result[j] ^= result[j + 1];
          }
          root = QrCode.reedSolomonMultiply(root, 0x02);
        }
        return result;
      };

      QrCode.reedSolomonComputeRemainder = function(data, divisor) {
        var result = divisor.map(function() { return 0; });
        data.forEach(function(b) {
          var factor = b ^ result.shift();
          result.push(0);
          for (var i = 0; i < result.length; i++)
            result[i] ^= QrCode.reedSolomonMultiply(divisor[i], factor);
        });
        return result;
      };

      QrCode.reedSolomonMultiply = function(x, y) {
        var z = 0;
        for (var i = 7; i >= 0; i--) {
          z = (z << 1) ^ ((z >>> 7) * 0x11D);
          if (((y >>> i) & 1) !== 0) z ^= x;
        }
        return z & 0xFF;
      };

      QrCode.getNumDataCodewords = function(version, ecl) {
        return QrCode.getNumRawDataModules(version) / 8
          - QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][version] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][version];
      };

      QrCode.getNumRawDataModules = function(ver) {
        var result = (16 * ver + 128) * ver + 64;
        if (ver >= 2) {
          var numAlign = Math.floor(ver / 7) + 2;
          result -= (25 * numAlign - 10) * numAlign - 55;
          if (ver >= 7) result -= 36;
        }
        return result;
      };

      QrCode.appendBits = function(val, len, bb) {
        for (var i = len - 1; i >= 0; i--) bb.push(((val >>> i) & 1) !== 0);
      };

      QrCode.getBit = function(x, i) { return ((x >>> i) & 1) !== 0; };

      QrCode.Ecc = function(ordinal, formatBits) { this.ordinal = ordinal; this.formatBits = formatBits; };
      QrCode.Ecc.values = [
        new QrCode.Ecc(0, 1),
        new QrCode.Ecc(1, 0),
        new QrCode.Ecc(2, 3),
        new QrCode.Ecc(3, 2)
      ];
      QrCode.Ecc.LOW = QrCode.Ecc.values[0];
      QrCode.Ecc.MEDIUM = QrCode.Ecc.values[1];
      QrCode.Ecc.QUARTILE = QrCode.Ecc.values[2];
      QrCode.Ecc.HIGH = QrCode.Ecc.values[3];

      // Tables (version indexed 1..40, keep 0 as dummy)
      QrCode.ECC_CODEWORDS_PER_BLOCK = [
        [0, 7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],
        [0,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],
        [0,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],
        [0,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30]
      ];

      QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
        [0,1,1,1,1,1,2,2,2,2,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25,26],
        [0,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49],
        [0,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68],
        [0,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]
      ];

      function QrSegment(mode, numChars, data) { this.mode = mode; this.numChars = numChars; this.data = data; }

      QrSegment.makeSegments = function(text) {
        var bytes = QrSegment.toUtf8ByteArray(text);
        var data = [];
        for (var i = 0; i < bytes.length; i++)
          QrCode.appendBits(bytes[i], 8, data);
        return [new QrSegment(QrSegment.Mode.BYTE, bytes.length, data)];
      };

      QrSegment.getTotalBits = function(segs, version) {
        var result = 0;
        for (var i = 0; i < segs.length; i++) {
          var seg = segs[i];
          var ccbits = seg.mode.numCharCountBits(version);
          if (seg.numChars >= (1 << ccbits)) return null;
          result += 4 + ccbits + seg.data.length;
        }
        return result;
      };

      QrSegment.toUtf8ByteArray = function(str) {
        var result = [];
        for (var i = 0; i < str.length; i++) {
          var c = str.charCodeAt(i);
          if (c < 0x80) result.push(c);
          else if (c < 0x800) {
            result.push(0xC0 | (c >>> 6));
            result.push(0x80 | (c & 0x3F));
          } else if (0xD800 <= c && c <= 0xDBFF) {
            if (i + 1 >= str.length) throw "Invalid UTF-16";
            var c2 = str.charCodeAt(++i);
            var codePoint = 0x10000 + (((c & 0x3FF) << 10) | (c2 & 0x3FF));
            result.push(0xF0 | (codePoint >>> 18));
            result.push(0x80 | ((codePoint >>> 12) & 0x3F));
            result.push(0x80 | ((codePoint >>> 6) & 0x3F));
            result.push(0x80 | (codePoint & 0x3F));
          } else {
            result.push(0xE0 | (c >>> 12));
            result.push(0x80 | ((c >>> 6) & 0x3F));
            result.push(0x80 | (c & 0x3F));
          }
        }
        return result;
      };

      QrSegment.Mode = {
        BYTE: {
          modeBits: 4,
          numCharCountBits: function(ver) { return ver <= 9 ? 8 : 16; }
        }
      };

      return { QrCode: QrCode, QrSegment: QrSegment };
    })();
    /* eslint-enable */
  </script>
</body>
</html>
