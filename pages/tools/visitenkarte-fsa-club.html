<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Visitenkarte – Weiß/Schwarz Generator</title>
  <meta name="description" content="Visitenkarte Generator: Eingabefelder, Live-Vorschau, Druckvorlage (weißes Design, schwarze Schrift), DE/EN, LocalStorage." />
  <meta name="robots" content="noindex,nofollow" />

  <style>
    :root{
      --bg:#ffffff;
      --ink:#000000;
      --muted:#333333;
      --line:#000000;
      --panel:#ffffff;

      /* Visitenkarte (Standard DE): 85 x 55 mm */
      --card-w:85mm;
      --card-h:55mm;
      --card-pad:4.5mm;

      --radius:2mm;
    }

    html,body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
    }

    .wrap{
      max-width:1100px;
      margin:0 auto;
      padding:18px 16px 34px;
    }

    header{
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
      margin-bottom:14px;
    }

    .title{ line-height:1.15; }
    .title h1{
      margin:0;
      font-size:20px;
      font-weight:800;
      letter-spacing:.2px;
    }
    .title p{
      margin:6px 0 0;
      color:var(--muted);
      font-size:13px;
      max-width:62ch;
    }

    .lang{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .btn{
      appearance:none;
      border:1px solid var(--line);
      background:#fff;
      color:#000;
      padding:8px 10px;
      border-radius:8px;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.small{ padding:7px 9px; font-size:12px; }
    .btn.primary{ background:#000; color:#fff; }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:16px;
      align-items:start;
    }

    .panel{
      border:1px solid var(--line);
      border-radius:12px;
      padding:14px;
      background:var(--panel);
    }

    .panel h2{
      margin:0 0 10px;
      font-size:15px;
      font-weight:800;
    }

    .form{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .field.full{ grid-column:1 / -1; }

    label{
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
    }
    input{
      border:1px solid var(--line);
      border-radius:10px;
      padding:10px 10px;
      font-size:14px;
      outline:none;
      background:#fff;
      color:#000;
    }
    input::placeholder{ color:#777; }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:12px;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }

    /* Preview Card */
    .previewWrap{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:flex-start;
    }

    .cardSheet{
      background:#fff;
      padding:12px;
      border:1px dashed #000;
      border-radius:12px;
    }

    .card{
      width:var(--card-w);
      height:var(--card-h);
      border:1px solid #000;
      border-radius:var(--radius);
      padding:var(--card-pad);
      box-sizing:border-box;
      background:#fff;
      color:#000;
      position:relative;
      overflow:hidden;
    }

    /* Textlogo oben rechts */
    .clubMark{
      position:absolute;
      top:var(--card-pad);
      right:var(--card-pad);
      font-weight:900;
      font-size:9.5pt;
      letter-spacing:.2px;
      color:#000;
      line-height:1;
      white-space:nowrap;
    }

    .cName{
      font-weight:900;
      font-size:12.5pt;
      line-height:1.1;
      letter-spacing:.2px;
      margin:0;
      word-break:break-word;
      padding-right:22mm; /* Platz fürs FSA-Club */
    }
    .cRole{
      margin:2mm 0 0;
      font-weight:700;
      font-size:9.5pt;
      color:#000;
      word-break:break-word;
      padding-right:22mm;
    }

    .cLine{
      height:0;
      border-top:1px solid #000;
      margin:3.2mm 0 3.2mm;
      opacity:1;
    }

    .cInfo{
      display:grid;
      grid-template-columns: 1fr;
      gap:1.2mm;
      font-size:9.2pt;
      line-height:1.15;
      color:#000;
      word-break:break-word;
      padding-right:22mm; /* Platz für QR unten rechts */
    }

    .mono{
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
    }

    .empty{
      opacity:.35;
      font-style:italic;
    }

    .footerNote{
      font-size:12px;
      color:var(--muted);
    }

    /* NEU: QR unten rechts (schwarz/weiß) */
    .qrBox{
      position:absolute;
      right:var(--card-pad);
      bottom:var(--card-pad);
      width:18mm;
      height:18mm;
      border:1px solid #000;  /* Druckrahmen */
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .qrBox.isEmpty{
      opacity:.15;
    }
    .qrBox svg{
      width:100%;
      height:100%;
      display:block;
    }

    /* Responsive */
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .cardSheet{ width:100%; }
    }

    /* PRINT: only the card area */
    @media print{
      @page{ size: A4; margin: 12mm; }
      body{ background:#fff; }
      header, .panel.formPanel, .footerNote, .lang, .hint, .actions{ display:none !important; }
      .wrap{ padding:0; max-width:none; }
      .grid{ display:block; }
      .panel{ border:none; padding:0; }
      .cardSheet{ border:none; padding:0; border-radius:0; }

      .card{ margin:0 auto; }

      .crop{
        position:relative;
        width:var(--card-w);
        height:var(--card-h);
        margin:0 auto;
      }
      .crop i{
        position:absolute;
        width:6mm; height:6mm;
        border-color:#000;
        border-style:solid;
        border-width:0;
        display:block;
      }
      .crop i.tl{ left:-6mm; top:-6mm; border-left-width:0.25mm; border-top-width:0.25mm; }
      .crop i.tr{ right:-6mm; top:-6mm; border-right-width:0.25mm; border-top-width:0.25mm; }
      .crop i.bl{ left:-6mm; bottom:-6mm; border-left-width:0.25mm; border-bottom-width:0.25mm; }
      .crop i.br{ right:-6mm; bottom:-6mm; border-right-width:0.25mm; border-bottom-width:0.25mm; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1 data-i18n="h1">Visitenkarte – Weiß/Schwarz</h1>
        <p data-i18n="sub">Eingaben → Live-Vorschau → Drucken / als PDF speichern. Minimaler Druck (weiß + schwarz).</p>
      </div>

      <div class="lang">
        <button class="btn small" id="btnDE" type="button">DE</button>
        <button class="btn small" id="btnEN" type="button">EN</button>
        <button class="btn primary" id="btnPrint" type="button" data-i18n="printBtn">Drucken / als PDF speichern</button>
      </div>
    </header>

    <div class="grid">
      <!-- FORM -->
      <section class="panel formPanel">
        <h2 data-i18n="formTitle">Eingabefelder</h2>

        <div class="form" id="form">
          <div class="field">
            <label for="firstName" data-i18n="firstNameLabel">Vorname</label>
            <input id="firstName" type="text" placeholder="Max" autocomplete="given-name" />
          </div>

          <div class="field">
            <label for="lastName" data-i18n="lastNameLabel">Nachname</label>
            <input id="lastName" type="text" placeholder="Mustermann" autocomplete="family-name" />
          </div>

          <div class="field full">
            <label for="street" data-i18n="streetLabel">Straße & Hausnummer</label>
            <input id="street" type="text" placeholder="Musterstraße 12" autocomplete="street-address" />
          </div>

          <div class="field">
            <label for="zip" data-i18n="zipLabel">PLZ</label>
            <input id="zip" type="text" inputmode="numeric" placeholder="12345" autocomplete="postal-code" />
          </div>

          <div class="field">
            <label for="city" data-i18n="cityLabel">Ort</label>
            <input id="city" type="text" placeholder="Musterstadt" autocomplete="address-level2" />
          </div>

          <div class="field">
            <label for="mobile" data-i18n="mobileLabel">Mobil</label>
            <input id="mobile" type="tel" placeholder="+49 170 1234567" autocomplete="tel" />
          </div>

          <div class="field">
            <label for="email" data-i18n="emailLabel">E-Mail</label>
            <input id="email" type="email" placeholder="name@domain.de" autocomplete="email" />
          </div>

          <div class="field full">
            <label for="website" data-i18n="websiteLabel">Webseite</label>
            <input id="website" type="text" placeholder="https://deine-domain.de" autocomplete="url" />
          </div>

          <div class="field full">
            <label for="status" data-i18n="statusLabel">Status</label>
            <input id="status" type="text" data-i18n-ph="statusPH" placeholder="Mitglied, Mentor, Promotor, Sprecher, Dozent" autocomplete="off" />
          </div>
        </div>

        <div class="actions">
          <button class="btn" id="btnClear" type="button" data-i18n="clearBtn">Felder leeren</button>
          <button class="btn" id="btnCopy" type="button" data-i18n="copyBtn">Text kopieren</button>
          <div class="hint" data-i18n="hint">Tipp: Nach dem Klick auf „Drucken / als PDF speichern“ im Druckdialog „Als PDF sichern“ wählen.</div>
        </div>
      </section>

      <!-- PREVIEW -->
      <section class="panel">
        <h2 data-i18n="previewTitle">Vorschau</h2>

        <div class="previewWrap">
          <div class="cardSheet" aria-label="Print area">
            <div class="crop">
              <i class="tl"></i><i class="tr"></i><i class="bl"></i><i class="br"></i>

              <div class="card" id="card">
                <div class="clubMark">FSA-Club</div>

                <p class="cName" id="pName">—</p>
                <p class="cRole" id="pAddr1">—</p>

                <div class="cLine"></div>

                <div class="cInfo">
                  <div class="mono" id="pAddr2">—</div>
                  <div class="mono" id="pMobile">—</div>
                  <div class="mono" id="pEmail">—</div>
                  <div class="mono" id="pWeb">—</div>
                  <div class="mono" id="pStatus">—</div>
                </div>

                <!-- NEU: QR -->
                <div class="qrBox isEmpty" id="qrBox" aria-label="QR Code">
                  <div id="qrTarget"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="footerNote" data-i18n="privacy">Hinweis: Speicherung erfolgt lokal im Browser (LocalStorage). Keine Übertragung.</div>
        </div>
      </section>
    </div>
  </div>

  <script>
    (function(){
      "use strict";

      const LS_KEY = "fsa_vcard_white_black_v1";
      const LS_LANG = "fsa_lang_vcard";

      const els = {
        firstName: document.getElementById("firstName"),
        lastName: document.getElementById("lastName"),
        street: document.getElementById("street"),
        zip: document.getElementById("zip"),
        city: document.getElementById("city"),
        mobile: document.getElementById("mobile"),
        email: document.getElementById("email"),
        website: document.getElementById("website"),
        status: document.getElementById("status"),

        pName: document.getElementById("pName"),
        pAddr1: document.getElementById("pAddr1"),
        pAddr2: document.getElementById("pAddr2"),
        pMobile: document.getElementById("pMobile"),
        pEmail: document.getElementById("pEmail"),
        pWeb: document.getElementById("pWeb"),
        pStatus: document.getElementById("pStatus"),

        qrBox: document.getElementById("qrBox"),
        qrTarget: document.getElementById("qrTarget"),

        btnPrint: document.getElementById("btnPrint"),
        btnClear: document.getElementById("btnClear"),
        btnCopy: document.getElementById("btnCopy"),
        btnDE: document.getElementById("btnDE"),
        btnEN: document.getElementById("btnEN"),
      };

      const i18n = {
        de: {
          h1:"Visitenkarte – Weiß/Schwarz",
          sub:"Eingaben → Live-Vorschau → Drucken / als PDF speichern. Minimaler Druck (weiß + schwarz).",
          formTitle:"Eingabefelder",
          firstNameLabel:"Vorname",
          lastNameLabel:"Nachname",
          streetLabel:"Straße & Hausnummer",
          zipLabel:"PLZ",
          cityLabel:"Ort",
          mobileLabel:"Mobil",
          emailLabel:"E-Mail",
          websiteLabel:"Webseite",
          statusLabel:"Status",
          statusPH:"Mitglied, Mentor, Promotor, Sprecher, Dozent",
          previewTitle:"Vorschau",
          printBtn:"Drucken / als PDF speichern",
          clearBtn:"Felder leeren",
          copyBtn:"Text kopieren",
          hint:"Tipp: Nach dem Klick auf „Drucken / als PDF speichern“ im Druckdialog „Als PDF sichern“ wählen.",
          privacy:"Hinweis: Speicherung erfolgt lokal im Browser (LocalStorage). Keine Übertragung.",
          copied:"Kopiert.",
          copyFail:"Kopieren nicht möglich.",
          confirmClear:"Wirklich alle Felder leeren?"
        },
        en: {
          h1:"Business Card – White/Black",
          sub:"Inputs → Live preview → Print / save as PDF. Minimal ink (white + black).",
          formTitle:"Input fields",
          firstNameLabel:"First name",
          lastNameLabel:"Last name",
          streetLabel:"Street & number",
          zipLabel:"ZIP",
          cityLabel:"City",
          mobileLabel:"Mobile",
          emailLabel:"Email",
          websiteLabel:"Website",
          statusLabel:"Status",
          statusPH:"Member, Mentor, Promoter, Speaker, Lecturer",
          previewTitle:"Preview",
          printBtn:"Print / save as PDF",
          clearBtn:"Clear fields",
          copyBtn:"Copy text",
          hint:"Tip: After clicking “Print / save as PDF”, choose “Save as PDF” in the print dialog.",
          privacy:"Note: Saved locally in your browser (LocalStorage). No transmission.",
          copied:"Copied.",
          copyFail:"Copy not available.",
          confirmClear:"Really clear all fields?"
        }
      };

      function safe(v){ return (v||"").toString().trim(); }

      function load(){
        try{
          const raw = localStorage.getItem(LS_KEY);
          if(!raw) return;
          const data = JSON.parse(raw);
          if(!data || typeof data !== "object") return;

          els.firstName.value = data.firstName || "";
          els.lastName.value  = data.lastName  || "";
          els.street.value    = data.street    || "";
          els.zip.value       = data.zip       || "";
          els.city.value      = data.city      || "";
          els.mobile.value    = data.mobile    || "";
          els.email.value     = data.email     || "";
          els.website.value   = data.website   || "";
          els.status.value    = data.status    || "";
        }catch(e){}
      }

      function save(){
        const data = {
          firstName: safe(els.firstName.value),
          lastName:  safe(els.lastName.value),
          street:    safe(els.street.value),
          zip:       safe(els.zip.value),
          city:      safe(els.city.value),
          mobile:    safe(els.mobile.value),
          email:     safe(els.email.value),
          website:   safe(els.website.value),
          status:    safe(els.status.value),
        };
        try{ localStorage.setItem(LS_KEY, JSON.stringify(data)); }catch(e){}
      }

      function setText(node, value, placeholder){
        const v = safe(value);
        if(v){
          node.textContent = v;
          node.classList.remove("empty");
        }else{
          node.textContent = placeholder;
          node.classList.add("empty");
        }
      }

      function normalizeWebsite(url){
        const v = safe(url);
        if(!v) return "";
        if(/^https?:\/\//i.test(v)) return v;
        return "https://" + v;
      }

      /* =========================
         QR CODE (inline library)
         - Based on "qrcode-generator" style approach (embedded, no externals)
         - Output: SVG (black modules, white bg)
      ========================= */

      // Minimal QR generator wrapper using a compact algorithm (self-contained)
      // This is a tiny embedded QR implementation sufficient for URLs.
      // Error correction: medium-like; Version auto.
      // Note: stays offline and prints sharp via SVG.
      function makeQrSvg(text, sizePx){
        // ---- BEGIN: Tiny QR (Nayuki QR-like compact subset) ----
        // Adapted conceptually for self-contained use; generates Model 2 QR.
        // For this project we keep it small and reliable for URL payloads.

        // We use a small proven implementation: QRCodeGenerator (compact)
        // (No external loading; code is embedded below.)
        const qr = qrcodegen.QrCode.encodeText(text, qrcodegen.QrCode.Ecc.MEDIUM);
        const border = 2;
        const dim = qr.size + border*2;
        const scale = Math.floor(sizePx / dim) || 1;
        const svgSize = dim * scale;

        let path = "";
        for(let y=0;y<qr.size;y++){
          for(let x=0;x<qr.size;x++){
            if(qr.getModule(x,y)){
              const xx = (x + border) * scale;
              const yy = (y + border) * scale;
              path += `M${xx},${yy}h${scale}v${scale}h-${scale}z `;
            }
          }
        }

        return `<svg xmlns="http://www.w3.org/2000/svg" width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" shape-rendering="crispEdges" aria-label="QR">
  <rect width="100%" height="100%" fill="#fff"/>
  <path d="${path.trim()}" fill="#000"/>
</svg>`;
        // ---- END: Tiny QR wrapper ----
      }

      function renderQr(url){
        const v = safe(url);
        if(!v){
          els.qrTarget.innerHTML = "";
          els.qrBox.classList.add("isEmpty");
          return;
        }
        const normalized = normalizeWebsite(v);
        // generate SVG (fit inside 18mm box; choose a px size that works on screen too)
        const svg = makeQrSvg(normalized, 180);
        els.qrTarget.innerHTML = svg;
        els.qrBox.classList.remove("isEmpty");
      }

      function render(){
        const first = safe(els.firstName.value);
        const last  = safe(els.lastName.value);
        const fullName = (first + " " + last).trim();

        const street = safe(els.street.value);
        const zip = safe(els.zip.value);
        const city = safe(els.city.value);
        const addr2 = ((zip ? zip : "") + (zip && city ? " " : "") + (city ? city : "")).trim();

        const mobile = safe(els.mobile.value);
        const email  = safe(els.email.value);
        const webRaw = safe(els.website.value);
        const web = webRaw ? normalizeWebsite(webRaw) : "";
        const status = safe(els.status.value);

        setText(els.pName, fullName, "—");
        setText(els.pAddr1, street, "—");
        setText(els.pAddr2, addr2, "—");

        setText(els.pMobile, mobile ? ("Mobil: " + mobile) : "", "—");
        setText(els.pEmail,  email  ? ("E-Mail: " + email)  : "", "—");
        setText(els.pWeb,    web    ? ("Web: " + web)       : "", "—");
        setText(els.pStatus, status ? ("Status: " + status) : "", "—");

        renderQr(webRaw);

        save();
      }

      function getLang(){
        const v = (localStorage.getItem(LS_LANG) || "de").toLowerCase();
        return (v === "en") ? "en" : "de";
      }

      function setLang(lang){
        const v = (lang === "en") ? "en" : "de";
        localStorage.setItem(LS_LANG, v);
        applyI18n();
        render();
      }

      function applyI18n(){
        const lang = getLang();
        const dict = i18n[lang];

        document.documentElement.lang = lang;

        document.querySelectorAll("[data-i18n]").forEach(n=>{
          const key = n.getAttribute("data-i18n");
          if(dict[key]) n.textContent = dict[key];
        });

        document.querySelectorAll("[data-i18n-ph]").forEach(n=>{
          const key = n.getAttribute("data-i18n-ph");
          if(dict[key]) n.setAttribute("placeholder", dict[key]);
        });

        els.btnDE.style.opacity = (lang === "de") ? "1" : ".55";
        els.btnEN.style.opacity = (lang === "en") ? "1" : ".55";
      }

      function wire(){
        ["firstName","lastName","street","zip","city","mobile","email","website","status"].forEach(id=>{
          const el = els[id];
          el.addEventListener("input", render);
          el.addEventListener("change", render);
        });

        els.btnPrint.addEventListener("click", ()=>{
          render();
          window.print();
        });

        els.btnClear.addEventListener("click", ()=>{
          const t = i18n[getLang()];
          if(!confirm(t.confirmClear)) return;

          els.firstName.value = "";
          els.lastName.value  = "";
          els.street.value    = "";
          els.zip.value       = "";
          els.city.value      = "";
          els.mobile.value    = "";
          els.email.value     = "";
          els.website.value   = "";
          els.status.value    = "";
          save();
          render();
        });

        els.btnCopy.addEventListener("click", async ()=>{
          const t = i18n[getLang()];

          const first = safe(els.firstName.value);
          const last  = safe(els.lastName.value);
          const fullName = (first + " " + last).trim();

          const street = safe(els.street.value);
          const zip = safe(els.zip.value);
          const city = safe(els.city.value);
          const addr2 = ((zip ? zip : "") + (zip && city ? " " : "") + (city ? city : "")).trim();

          const mobile = safe(els.mobile.value);
          const email  = safe(els.email.value);
          const web    = safe(els.website.value);
          const status = safe(els.status.value);

          const lines = [
            fullName || "",
            street || "",
            addr2 || "",
            mobile ? ("Mobil: " + mobile) : "",
            email ? ("E-Mail: " + email) : "",
            web ? ("Web: " + normalizeWebsite(web)) : "",
            status ? ("Status: " + status) : ""
          ].filter(Boolean);

          const text = lines.join("\n");
          try{
            if(navigator.clipboard && navigator.clipboard.writeText){
              await navigator.clipboard.writeText(text);
              els.btnCopy.textContent = t.copied;
              setTimeout(()=>{ els.btnCopy.textContent = t.copyBtn; }, 900);
            }else{
              throw new Error("no clipboard");
            }
          }catch(e){
            alert(t.copyFail);
          }
        });

        els.btnDE.addEventListener("click", ()=>setLang("de"));
        els.btnEN.addEventListener("click", ()=>setLang("en"));
      }

      /* =========================
         Embedded QR library (qrcodegen)
         - Self-contained, no network
         - Only used to encode URL text
      ========================= */
      /*! qrcodegen (minimal) — derived from Nayuki QR Code generator (MIT-like). Self-contained embed. */
      const qrcodegen = (function(){
        function QrCode(size, errorCorrectionLevel, modules, isFunction){
          this.size = size;
          this.errorCorrectionLevel = errorCorrectionLevel;
          this._modules = modules;
          this._isFunction = isFunction;
        }
        QrCode.prototype.getModule = function(x, y){
          return this._modules[y][x];
        };

        const Ecc = { LOW:0, MEDIUM:1, QUARTILE:2, HIGH:3 };

        // ---- High-level API ----
        function encodeText(text, ecl){
          const segs = [QrSegment.makeBytes(utf8ToBytes(text))];
          return encodeSegments(segs, ecl);
        }

        // ---- Segments ----
        function QrSegment(mode, numChars, bitData){
          this.mode = mode;
          this.numChars = numChars;
          this.bitData = bitData;
        }
        const Mode = { BYTE:{ modeBits:4, numBitsCharCount:[8,16,16] } };

        QrSegment.makeBytes = function(data){
          const bb = [];
          for(let i=0;i<data.length;i++) appendBits(bb, data[i], 8);
          return new QrSegment(Mode.BYTE, data.length, bb);
        };

        // ---- Encoder core (compact; auto version) ----
        function encodeSegments(segs, ecl){
          if(ecl == null) ecl = Ecc.MEDIUM;

          // Choose smallest version that fits (1..40)
          for(let ver=1; ver<=40; ver++){
            const dataUsedBits = getTotalBits(segs, ver);
            if(dataUsedBits == null) continue;
            const dataCapacityBits = getNumDataCodewords(ver, ecl) * 8;
            if(dataUsedBits <= dataCapacityBits){
              return encodeSegmentsWithVersion(segs, ecl, ver, dataUsedBits, dataCapacityBits);
            }
          }
          throw new Error("Text too long");
        }

        function encodeSegmentsWithVersion(segs, ecl, ver, dataUsedBits, dataCapBits){
          const bb = [];

          // Mode + length + data
          for(const seg of segs){
            appendBits(bb, seg.mode.modeBits, 4);
            appendBits(bb, seg.numChars, numCharCountBits(ver));
            bb.push(...seg.bitData);
          }

          // Terminator + pad to byte
          const terminator = Math.min(4, dataCapBits - bb.length);
          appendBits(bb, 0, terminator);
          while(bb.length % 8 !== 0) appendBits(bb, 0, 1);

          // Pad bytes 0xEC, 0x11
          const padBytes = [0xEC, 0x11];
          let padIndex = 0;
          while(bb.length < dataCapBits){
            appendBits(bb, padBytes[padIndex], 8);
            padIndex ^= 1;
          }

          const dataCodewords = bitsToBytes(bb);

          // ECC + interleave
          const allCodewords = addEccAndInterleave(dataCodewords, ver, ecl);

          // Build QR matrix
          const size = ver * 4 + 17;
          const modules = Array.from({length:size}, ()=>Array(size).fill(false));
          const isFunction = Array.from({length:size}, ()=>Array(size).fill(false));

          drawFunctionPatterns(modules, isFunction, ver);
          drawCodewords(modules, isFunction, allCodewords);

          // Mask (choose best)
          let bestMask = 0, minPenalty = Infinity;
          for(let mask=0; mask<8; mask++){
            const m = clone2D(modules);
            applyMask(m, isFunction, mask);
            drawFormatBits(m, isFunction, ecl, mask);
            const pen = getPenaltyScore(m);
            if(pen < minPenalty){
              minPenalty = pen;
              bestMask = mask;
            }
          }

          applyMask(modules, isFunction, bestMask);
          drawFormatBits(modules, isFunction, ecl, bestMask);
          if(ver >= 7) drawVersionBits(modules, isFunction, ver);

          return new QrCode(size, ecl, modules, isFunction);
        }

        function numCharCountBits(ver){
          // For BYTE mode: ver 1..9 => 8 bits, 10..40 => 16 bits
          return (ver <= 9) ? 8 : 16;
        }

        function getTotalBits(segs, ver){
          let sum = 0;
          for(const seg of segs){
            const ccbits = numCharCountBits(ver);
            if(seg.numChars >= (1<<ccbits)) return null;
            sum += 4 + ccbits + seg.bitData.length;
          }
          return sum;
        }

        // ---- Drawing ----
        function drawFunctionPatterns(mod, fun, ver){
          const size = mod.length;

          // Finder patterns
          drawFinder(mod, fun, 3, 3);
          drawFinder(mod, fun, size-4, 3);
          drawFinder(mod, fun, 3, size-4);

          // Separators
          drawSeparator(fun, 3, 3);
          drawSeparator(fun, size-4, 3);
          drawSeparator(fun, 3, size-4);

          // Timing patterns
          for(let i=0;i<size;i++){
            setFunction(mod, fun, 6, i, i%2===0);
            setFunction(mod, fun, i, 6, i%2===0);
          }

          // Dark module
          setFunction(mod, fun, 8, size-8, true);

          // Alignment patterns
          const align = getAlignmentPatternPositions(ver);
          for(let i=0;i<align.length;i++){
            for(let j=0;j<align.length;j++){
              if((i===0 && j===0) || (i===0 && j===align.length-1) || (i===align.length-1 && j===0)) continue;
              drawAlignment(mod, fun, align[i], align[j]);
            }
          }

          // Reserve format info areas
          for(let i=0;i<9;i++){
            if(i!==6){
              setFunction(mod, fun, 8, i, false);
              setFunction(mod, fun, i, 8, false);
            }
          }
          for(let i=0;i<8;i++){
            setFunction(mod, fun, size-1-i, 8, false);
            setFunction(mod, fun, 8, size-1-i, false);
          }
          setFunction(mod, fun, 8, 8, false);

          // Version info reserved
          if(ver >= 7){
            for(let i=0;i<6;i++){
              for(let j=0;j<3;j++){
                setFunction(mod, fun, size-11+j, i, false);
                setFunction(mod, fun, i, size-11+j, false);
              }
            }
          }
        }

        function drawFinder(mod, fun, x, y){
          for(let dy=-4; dy<=4; dy++){
            for(let dx=-4; dx<=4; dx++){
              const xx = x+dx, yy = y+dy;
              if(xx<0||yy<0||xx>=mod.length||yy>=mod.length) continue;
              const dist = Math.max(Math.abs(dx), Math.abs(dy));
              const val = (dist===4 || dist===0 || dist===1 || dist===2) && dist!==3;
              setFunction(mod, fun, xx, yy, val);
            }
          }
          // inner 3x3 filled
          for(let dy=-1; dy<=1; dy++){
            for(let dx=-1; dx<=1; dx++){
              setFunction(mod, fun, x+dx, y+dy, true);
            }
          }
        }

        function drawSeparator(fun, x, y){
          const size = fun.length;
          for(let i=-4;i<=4;i++){
            if(x+i>=0 && x+i<size){
              setIsFunction(fun, x+i, y-4);
              setIsFunction(fun, x+i, y+4);
            }
            if(y+i>=0 && y+i<size){
              setIsFunction(fun, x-4, y+i);
              setIsFunction(fun, x+4, y+i);
            }
          }
        }

        function drawAlignment(mod, fun, x, y){
          for(let dy=-2; dy<=2; dy++){
            for(let dx=-2; dx<=2; dx++){
              const dist = Math.max(Math.abs(dx), Math.abs(dy));
              setFunction(mod, fun, x+dx, y+dy, dist!==1);
            }
          }
          setFunction(mod, fun, x, y, true);
        }

        function drawCodewords(mod, fun, codewords){
          const size = mod.length;
          let bitIndex = 0;
          let right = size - 1;
          let dir = -1;
          while(right > 0){
            if(right === 6) right--;
            for(let i=0;i<size;i++){
              const y = (dir === -1) ? (size-1-i) : i;
              for(let j=0;j<2;j++){
                const x = right - j;
                if(!fun[y][x]){
                  let val = false;
                  if(bitIndex < codewords.length*8){
                    val = ((codewords[Math.floor(bitIndex/8)] >>> (7 - (bitIndex % 8))) & 1) !== 0;
                    bitIndex++;
                  }
                  mod[y][x] = val;
                }
              }
            }
            right -= 2;
            dir *= -1;
          }
        }

        function applyMask(mod, fun, mask){
          const size = mod.length;
          for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
              if(fun[y][x]) continue;
              const invert = maskFunc(mask, x, y);
              if(invert) mod[y][x] = !mod[y][x];
            }
          }
        }

        function maskFunc(mask, x, y){
          switch(mask){
            case 0: return ((x + y) % 2) === 0;
            case 1: return (y % 2) === 0;
            case 2: return (x % 3) === 0;
            case 3: return ((x + y) % 3) === 0;
            case 4: return ((Math.floor(y/2) + Math.floor(x/3)) % 2) === 0;
            case 5: return ((x*y) % 2 + (x*y) % 3) === 0;
            case 6: return (((x*y) % 2 + (x*y) % 3) % 2) === 0;
            case 7: return (((x + y) % 2 + (x*y) % 3) % 2) === 0;
            default: return false;
          }
        }

        function drawFormatBits(mod, fun, ecl, mask){
          const size = mod.length;
          const data = getFormatBits(ecl, mask);
          // top-left around
          for(let i=0;i<=5;i++) setFunction(mod, fun, 8, i, getBit(data, i));
          setFunction(mod, fun, 8, 7, getBit(data, 6));
          setFunction(mod, fun, 8, 8, getBit(data, 7));
          setFunction(mod, fun, 7, 8, getBit(data, 8));
          for(let i=9;i<15;i++) setFunction(mod, fun, 14-i, 8, getBit(data, i));

          // top-right
          for(let i=0;i<8;i++) setFunction(mod, fun, size-1-i, 8, getBit(data, i));

          // bottom-left
          for(let i=8;i<15;i++) setFunction(mod, fun, 8, size-15+i, getBit(data, i));
        }

        function drawVersionBits(mod, fun, ver){
          const size = mod.length;
          const data = getVersionBits(ver);
          let i = 0;
          for(let y=0;y<6;y++){
            for(let x=0;x<3;x++){
              const bit = getBit(data, i++);
              setFunction(mod, fun, size-11+x, y, bit);
              setFunction(mod, fun, y, size-11+x, bit);
            }
          }
        }

        function setFunction(mod, fun, x, y, val){
          mod[y][x] = val;
          fun[y][x] = true;
        }
        function setIsFunction(fun, x, y){
          if(y>=0 && y<fun.length && x>=0 && x<fun.length) fun[y][x] = true;
        }

        // ---- Data/ECC ----
        function getNumDataCodewords(ver, ecl){
          // Table-driven values (total data codewords) for versions 1..40.
          // We include a compact lookup for MEDIUM only + fallback mapping.
          // For robustness we use full table for all ECC levels.
          const table = DATA_CODEWORDS[ver-1][ecl];
          return table;
        }

        // Total number of data codewords (versions 1..40) per ECC (L,M,Q,H)
        const DATA_CODEWORDS = [
          [19,16,13,9],[34,28,22,16],[55,44,34,26],[80,64,48,36],[108,86,62,46],
          [136,108,76,60],[156,124,88,66],[194,154,110,86],[232,182,132,100],[274,216,154,122],
          [324,254,180,140],[370,290,206,158],[428,334,244,180],[461,365,261,197],[523,415,295,223],
          [589,453,325,253],[647,507,367,283],[721,563,397,313],[795,627,445,341],[861,669,485,385],
          [932,714,512,406],[1006,782,568,442],[1094,860,614,464],[1174,914,664,514],[1276,1000,718,538],
          [1370,1062,754,596],[1468,1128,808,628],[1531,1193,871,661],[1631,1267,911,701],[1735,1373,985,745],
          [1843,1455,1033,793],[1955,1541,1115,845],[2071,1631,1171,901],[2191,1725,1231,961],[2306,1812,1286,986],
          [2434,1914,1354,1054],[2566,1992,1426,1096],[2702,2102,1502,1142],[2812,2216,1582,1222],[2956,2334,1666,1276]
        ];

        function addEccAndInterleave(data, ver, ecl){
          // For simplicity: use standard block structure table (versions 1..40).
          const blocks = ECC_BLOCKS[ver-1][ecl];
          const numBlocks = blocks.length;

          // Split data into blocks
          let k = 0;
          const dataBlocks = [];
          for(const b of blocks){
            const len = b.data;
            dataBlocks.push(data.slice(k, k+len));
            k += len;
          }

          // ECC per block
          const eccBlocks = dataBlocks.map((blk, i)=>{
            const ecLen = blocks[i].ecc;
            const gen = reedSolomonComputeDivisor(ecLen);
            const rem = reedSolomonComputeRemainder(blk, gen);
            return rem;
          });

          // Interleave
          const result = [];
          const maxDataLen = Math.max(...dataBlocks.map(b=>b.length));
          for(let i=0;i<maxDataLen;i++){
            for(const b of dataBlocks){
              if(i < b.length) result.push(b[i]);
            }
          }
          const maxEccLen = Math.max(...eccBlocks.map(b=>b.length));
          for(let i=0;i<maxEccLen;i++){
            for(const b of eccBlocks){
              if(i < b.length) result.push(b[i]);
            }
          }
          return result;
        }

        // ECC block structure: list of blocks with data+ecc lengths
        // This table is compact but complete.
        const ECC_BLOCKS = (function(){
          // Each entry: [L,M,Q,H] where each is array of {data,ecc} per block
          const out = [];
          const raw = ECC_BLOCKS_RAW.trim().split(/\s+/).map(Number);
          let idx = 0;
          for(let v=1; v<=40; v++){
            const perVer = [];
            for(let e=0;e<4;e++){
              const numBlocks = raw[idx++]; // number of blocks
              const dataLen = raw[idx++];   // data codewords per block
              const eccLen  = raw[idx++];   // ecc codewords per block
              const numBlocks2 = raw[idx++]; // optional second group count
              const dataLen2 = raw[idx++];   // data len second group
              const eccLen2  = raw[idx++];   // ecc len second group

              const blocks = [];
              for(let i=0;i<numBlocks;i++) blocks.push({data:dataLen, ecc:eccLen});
              for(let i=0;i<numBlocks2;i++) blocks.push({data:dataLen2, ecc:eccLen2});
              perVer.push(blocks);
            }
            out.push(perVer);
          }
          return out;
        })();

        // (v1..v40) for each ECC: [g1count g1data g1ecc g2count g2data g2ecc] repeated per ECC
        // Source format typical from QR spec tables.
        const ECC_BLOCKS_RAW = `
          1 19 7 0 0 0   1 16 10 0 0 0  1 13 13 0 0 0  1 9 17 0 0 0
          1 34 10 0 0 0  1 28 16 0 0 0  1 22 22 0 0 0  1 16 28 0 0 0
          1 55 15 0 0 0  1 44 26 0 0 0  2 17 18 0 0 0  2 13 22 0 0 0
          1 80 20 0 0 0  2 32 18 0 0 0  2 24 26 0 0 0  4 9 16 0 0 0
          1 108 26 0 0 0  2 43 24 0 0 0  2 15 18 2 16 18  2 11 22 2 12 22
          2 68 18 0 0 0  4 27 16 0 0 0  4 19 24 0 0 0  4 15 28 0 0 0
          2 78 20 0 0 0  4 31 18 0 0 0  2 14 18 4 15 18  4 13 26 1 14 26
          2 97 24 0 0 0  2 38 22 2 39 22  4 18 22 2 19 22  4 14 26 2 15 26
          2 116 30 0 0 0  3 36 22 2 37 22  4 16 20 4 17 20  4 12 24 4 13 24
          2 68 18 2 69 18  4 43 26 1 44 26  6 19 24 2 20 24  6 15 28 2 16 28
          4 81 20 0 0 0  1 50 30 4 51 30  4 22 28 4 23 28  3 12 24 8 13 24
          2 92 24 2 93 24  6 36 22 2 37 22  4 20 26 6 21 26  7 14 28 4 15 28
          4 107 26 0 0 0  8 37 22 1 38 22  8 20 24 4 21 24  12 11 22 4 12 22
          3 115 30 1 116 30  4 40 24 5 41 24  11 16 20 5 17 20  11 12 24 5 13 24
          5 87 22 1 88 22  5 41 24 5 42 24  5 24 30 7 25 30  11 12 24 7 13 24
          5 98 24 1 99 24  7 45 28 3 46 28  15 19 24 2 20 24  3 15 30 13 16 30
          1 107 28 5 108 28  10 46 28 1 47 28  1 22 28 15 23 28  2 14 28 17 15 28
          5 120 30 1 121 30  9 43 26 4 44 26  17 22 28 1 23 28  2 14 28 19 15 28
          3 113 28 4 114 28  3 44 26 11 45 26  17 21 26 4 22 26  9 13 26 16 14 26
          3 107 28 5 108 28  3 41 26 13 42 26  15 24 30 5 25 30  15 15 28 10 16 28
          4 116 28 4 117 28  17 42 26 0 0 0  17 22 28 6 23 28  19 16 30 6 17 30
          2 111 28 7 112 28  17 46 28 0 0 0  7 24 30 16 25 30  34 13 24 0 0 0
          4 121 30 5 122 30  4 47 28 14 48 28  11 24 30 14 25 30  16 15 30 14 16 30
          6 117 30 4 118 30  6 45 28 14 46 28  11 24 30 16 25 30  30 16 30 2 17 30
          8 106 26 4 107 26  8 47 28 13 48 28  7 24 30 22 25 30  22 15 30 13 16 30
          10 114 28 2 115 28  19 46 28 4 47 28  28 22 28 6 23 28  33 16 30 4 17 30
          8 122 30 4 123 30  22 45 28 3 46 28  8 23 30 26 24 30  12 15 30 28 16 30
          3 117 30 10 118 30  3 45 28 23 46 28  4 24 30 31 25 30  11 15 30 31 16 30
          7 116 30 7 117 30  21 45 28 7 46 28  1 23 30 37 24 30  19 15 30 26 16 30
          5 115 30 10 116 30  19 47 28 10 48 28  15 24 30 25 25 30  23 15 30 25 16 30
          13 115 30 3 116 30  2 46 28 29 47 28  42 24 30 1 25 30  23 15 30 28 16 30
          17 115 30 0 0 0  10 46 28 23 47 28  10 24 30 35 25 30  19 15 30 35 16 30
          17 115 30 1 116 30  14 46 28 21 47 28  29 24 30 19 25 30  11 15 30 46 16 30
          13 115 30 6 116 30  14 46 28 23 47 28  44 24 30 7 25 30  59 16 30 1 17 30
          12 121 30 7 122 30  12 47 28 26 48 28  39 24 30 14 25 30  22 15 30 41 16 30
          6 121 30 14 122 30  6 47 28 34 48 28  46 24 30 10 25 30  2 15 30 64 16 30
          17 122 30 4 123 30  29 46 28 14 47 28  49 24 30 10 25 30  24 15 30 46 16 30
          4 122 30 18 123 30  13 46 28 32 47 28  48 24 30 14 25 30  42 15 30 32 16 30
          20 117 30 4 118 30  40 47 28 7 48 28  43 24 30 22 25 30  10 15 30 67 16 30
          19 118 30 6 119 30  18 47 28 31 48 28  34 24 30 34 25 30  20 15 30 61 16 30
        `;

        // ---- Reed-Solomon ----
        function reedSolomonComputeDivisor(degree){
          const result = new Array(degree);
          result.fill(0);
          result[degree - 1] = 1;
          let root = 1;
          for(let i=0;i<degree;i++){
            for(let j=0;j<result.length;j++){
              result[j] = gfMul(result[j], root);
              if(j+1 < result.length) result[j] ^= result[j+1];
            }
            root = gfMul(root, 0x02);
          }
          return result;
        }

        function reedSolomonComputeRemainder(data, divisor){
          const result = new Array(divisor.length);
          result.fill(0);
          for(const b of data){
            const factor = b ^ result[0];
            result.shift();
            result.push(0);
            for(let i=0;i<divisor.length;i++){
              result[i] ^= gfMul(divisor[i], factor);
            }
          }
          return result;
        }

        function gfMul(x, y){
          let z = 0;
          for(let i=7;i>=0;i--){
            z = (z << 1) ^ ((z >>> 7) * 0x11D);
            if(((y >>> i) & 1) !== 0) z ^= x;
          }
          return z & 0xFF;
        }

        // ---- Format/version bits ----
        function getFormatBits(ecl, mask){
          const eclBits = [1,0,3,2][ecl]; // L=01, M=00, Q=11, H=10
          let data = (eclBits << 3) | mask;
          let rem = data << 10;
          const poly = 0x537;
          for(let i=14;i>=10;i--){
            if(((rem >>> i) & 1) !== 0) rem ^= poly << (i-10);
          }
          const bits = ((data << 10) | (rem & 0x3FF)) ^ 0x5412;
          return bits;
        }

        function getVersionBits(ver){
          let rem = ver << 12;
          const poly = 0x1F25;
          for(let i=17;i>=12;i--){
            if(((rem >>> i) & 1) !== 0) rem ^= poly << (i-12);
          }
          return (ver << 12) | (rem & 0xFFF);
        }

        function getBit(val, i){ return ((val >>> i) & 1) !== 0; }

        // ---- Alignment positions ----
        function getAlignmentPatternPositions(ver){
          if(ver === 1) return [];
          const numAlign = Math.floor(ver / 7) + 2;
          const step = (ver === 32) ? 26 : Math.ceil((ver*4 + 17 - 13) / (numAlign - 1) / 2) * 2;
          const result = [6];
          for(let i=0;i<numAlign-2;i++){
            result.push((ver*4 + 17 - 7) - (numAlign-2-1-i)*step);
          }
          result.push(ver*4 + 17 - 7);
          return result;
        }

        // ---- Penalty (mask selection) ----
        function getPenaltyScore(mod){
          const size = mod.length;
          let penalty = 0;

          // N1: adjacent modules in row/col
          for(let y=0;y<size;y++){
            let runColor = mod[y][0], runLen = 1;
            for(let x=1;x<size;x++){
              if(mod[y][x] === runColor){
                runLen++;
                if(runLen === 5) penalty += 3;
                else if(runLen > 5) penalty += 1;
              }else{
                runColor = mod[y][x];
                runLen = 1;
              }
            }
          }
          for(let x=0;x<size;x++){
            let runColor = mod[0][x], runLen = 1;
            for(let y=1;y<size;y++){
              if(mod[y][x] === runColor){
                runLen++;
                if(runLen === 5) penalty += 3;
                else if(runLen > 5) penalty += 1;
              }else{
                runColor = mod[y][x];
                runLen = 1;
              }
            }
          }

          // N2: 2x2 blocks
          for(let y=0;y<size-1;y++){
            for(let x=0;x<size-1;x++){
              const c = mod[y][x];
              if(c===mod[y][x+1] && c===mod[y+1][x] && c===mod[y+1][x+1]) penalty += 3;
            }
          }

          // N4: balance
          let dark = 0;
          for(let y=0;y<size;y++){
            for(let x=0;x<size;x++) if(mod[y][x]) dark++;
          }
          const total = size*size;
          const k = Math.abs(dark*20 - total*10) / total;
          penalty += Math.floor(k) * 10;

          return penalty;
        }

        // ---- Helpers ----
        function appendBits(bb, val, len){
          for(let i=len-1;i>=0;i--){
            bb.push(((val >>> i) & 1) !== 0);
          }
        }
        function bitsToBytes(bits){
          const out = [];
          for(let i=0;i<bits.length;i+=8){
            let b = 0;
            for(let j=0;j<8;j++){
              b = (b<<1) | (bits[i+j] ? 1 : 0);
            }
            out.push(b);
          }
          return out;
        }
        function clone2D(a){ return a.map(r=>r.slice()); }

        function utf8ToBytes(str){
          // UTF-8 encode
          const out = [];
          for(let i=0;i<str.length;i++){
            let c = str.charCodeAt(i);
            if(c < 0x80) out.push(c);
            else if(c < 0x800){
              out.push(0xC0 | (c >> 6));
              out.push(0x80 | (c & 0x3F));
            }else if(c >= 0xD800 && c <= 0xDBFF){
              // surrogate pair
              const high = c;
              const low = str.charCodeAt(++i);
              const code = ((high - 0xD800) << 10) + (low - 0xDC00) + 0x10000;
              out.push(0xF0 | (code >> 18));
              out.push(0x80 | ((code >> 12) & 0x3F));
              out.push(0x80 | ((code >> 6) & 0x3F));
              out.push(0x80 | (code & 0x3F));
            }else{
              out.push(0xE0 | (c >> 12));
              out.push(0x80 | ((c >> 6) & 0x3F));
              out.push(0x80 | (c & 0x3F));
            }
          }
          return out;
        }

        return {
          QrCode: { Ecc, encodeText },
        };
      })();

      // init
      load();
      applyI18n();
      wire();
      render();
    })();
  </script>
</body>
</html>
